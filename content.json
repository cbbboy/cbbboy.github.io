{"meta":{"title":"自定义隧道","subtitle":"自定义隧道","description":"自定义隧道","author":"cbb boy","url":"https://cbbboy.github.io","root":"/"},"pages":[{"title":"分类","date":"2023-10-30T08:04:17.859Z","updated":"2023-10-20T04:04:09.466Z","comments":false,"path":"categories/index.html","permalink":"https://cbbboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"about me","date":"2023-10-12T02:08:59.000Z","updated":"2023-10-20T04:09:40.360Z","comments":true,"path":"about/index.html","permalink":"https://cbbboy.github.io/about/index.html","excerpt":"","text":"隧道小组组长！！！"}],"posts":[{"title":"隧道进阶06-隧道代码实现","slug":"隧道/隧道进阶06-隧道代码实现","date":"2023-10-28T02:08:59.000Z","updated":"2023-11-02T10:02:31.481Z","comments":true,"path":"zh-CN/隧道/隧道进阶06-隧道代码实现/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B606-%E9%9A%A7%E9%81%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"隧道代码实现（重点）进阶代码下载 对象的创建先看一下我们的对象，这个即是我的对象，里面包含内容 主连接 子连接 思路服务端服务端我们接受到tcp连接后，我们组装一个自己的对象后直接异步处理即可 我们从主连接里面获取到内容后如何处理 StartMainProcess() 通过sign找到对应的处理方法 process 中的tcp新建立连接的处理方法 process 中的tcp 断开连接的处理方法找到对应的subconn关闭连接，并且删除自己map中的conn即可 process 中的tcp 传递数据的处理方法找到对应的subconn直接调用wirte传入真实数据即可 process 中的tcp 回调的处理方法 客户端客户端接受到gvisor出来的tcp连接如何处理 那我们都需要处理什么 TcpProcess 子连接出来的数据如何封装进入隧道 StartSubTcpProcess 重点代码讲解完毕最后抓包查看隧道协议","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道进阶05-点对面隧道协议设计方案（重点）","slug":"隧道/隧道进阶05-点对面隧道协议设计方案","date":"2023-10-04T02:08:59.000Z","updated":"2023-11-02T07:47:48.051Z","comments":true,"path":"zh-CN/隧道/隧道进阶05-点对面隧道协议设计方案/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B605-%E7%82%B9%E5%AF%B9%E9%9D%A2%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/","excerpt":"","text":"点对面隧道协议设计方案（重点）进阶代码下载 我们拿到net.conn了之后，我们即可将流量封装进入隧道 那我们遇到第一个问题是什么呢？肯定是隧道协议需要设计成什么，本章讲解我们自己设计的隧道协议 隧道协议的设计我们需要先考虑-&gt;隧道服务端需要什么？ 目的ip 目的端口 协议 区分相同目的ip、相同端口、相同协议的不同连接 流量类型 解释1、2、3就不多讲了 4：是客户端可能会同时和10.50.1.211:22建立多条tcp连接，那我们服务端也需要多条和真实业务的连接，那我们只有目的ip，目的端口，协议，无法区分多个tcp连接，那我们就还需要一个唯一id进行区分 5：为了区分比如tcp新建立连接、tcp断开、tcp数据传递、服务端和客户端双向通信发送的信息、传递自己的令牌等。我们也可以把协议和流量类型合并为同一个字段 普通方案普通方案：每当客户端有流量过来的时候，都和服务端建立一条tcp连接用于发送数据 普通方案可以在刚和服务端建立好后，使用固定长度的内容传递自己的目的地址，用户信息等内容，服务端根据内容建立tcp后，然后再调用io.copy方法即可实现代理 优点： 没有额外计算 数据包不会变大 缺点： 每次都要和服务端的隧道建立连接和tls握手 服务端tcp连接数量明显较多 多路复用方案多路复用方案理论是：用一条或多条tcp承载vpn流量，而不是在使用的时候去建立隧道转发流量 优点： 可以省去和服务端建立tcp连接和tls握手时间 服务端tcp连接数量明显下降 缺点： 自己vpn协议头部会变大 服务端会有额外判断策略 方案0110 0 0 0 13 10.50.1.18:22-1.1.1.1:12345 sign xxxxxxxxxx 解析 方案02例子里面包括的是这样的 10 0 0 0 sign 13 10.50.1.18:22-1.1.1.1:12345 xxxxxxxxxx","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道进阶04-处理连接-本地放行+重写目的地址（udp）","slug":"隧道/隧道进阶04-处理连接-本地放行+重写目的地址（udp）","date":"2023-10-03T11:01:22.000Z","updated":"2023-10-31T10:59:54.815Z","comments":true,"path":"zh-CN/隧道/隧道进阶04-处理连接-本地放行+重写目的地址（udp）/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B604-%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5-%E6%9C%AC%E5%9C%B0%E6%94%BE%E8%A1%8C+%E9%87%8D%E5%86%99%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%88udp%EF%BC%89/","excerpt":"","text":"处理连接-本地放行（udp）进阶代码下载 udp和tcp几乎一样，但是udp是没有连接状态的，我们需要多设置一个超时时间，一旦超时，释放本地资源即可，一般这个时间我们设置到30s-60s左右即可 123456789101112131415161718192021222324var ( udpTimeout = 5 * time.Second)func udpProcessRewrite(conn net.Conn) &#123; fmt.Println(fmt.Sprintf(&quot;UDP ProcessRewrite dst remote addr:%v local addr:%v&quot;, conn.RemoteAddr().String(), conn.LocalAddr().String())) local, _ := net.ResolveUDPAddr(&quot;udp&quot;, &quot;10.11.36.35&quot;) remote, _ := net.ResolveUDPAddr(&quot;udp&quot;, &quot;10.50.1.18:9999&quot;) udpConn, err := net.DialUDP(&quot;udp&quot;, local, remote) if err != nil &#123; fmt.Println(fmt.Sprintf(&quot;net dial error:%v&quot;, err)) return &#125; go func() &#123; udpConn.SetDeadline(time.Now().Add(udpTimeout)) defer conn.Close() io.Copy(udpConn, conn) &#125;() go func() &#123; defer udpConn.Close() io.Copy(conn, udpConn) &#125;()&#125; 如果我们这样写，会发现一个问题，就是udp的一旦连上，5s之后就断开了 那我们应该怎么写，可以保证每次读写后30s再断开？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var ( udpTimeout = 5 * time.Second)func udpProcessRewrite(conn net.Conn) &#123; fmt.Println(fmt.Sprintf(&quot;UDP ProcessRewrite dst remote addr:%v local addr:%v&quot;, conn.RemoteAddr().String(), conn.LocalAddr().String())) local, _ := net.ResolveUDPAddr(&quot;udp&quot;, &quot;10.11.36.35&quot;) remote, _ := net.ResolveUDPAddr(&quot;udp&quot;, &quot;10.50.1.18:9999&quot;) udpConn, err := net.DialUDP(&quot;udp&quot;, local, remote) if err != nil &#123; fmt.Println(fmt.Sprintf(&quot;net dial error:%v&quot;, err)) return &#125; go func() &#123; defer func() &#123; conn.Close() fmt.Println(&quot;remote to local close!&quot;) &#125;() buf := make([]byte, 1024*32) for &#123; udpConn.SetDeadline(time.Now().Add(udpTimeout)) nr, err := udpConn.Read(buf) if err != nil &#123; return &#125; _, err = conn.Write(buf[0:nr]) if err != nil &#123; return &#125; &#125; &#125;() go func() &#123; defer func() &#123; fmt.Println(&quot;local to remote close!&quot;) udpConn.Close() &#125;() buf := make([]byte, 1024*32) for &#123; udpConn.SetDeadline(time.Now().Add(udpTimeout)) nr, err := conn.Read(buf) if err != nil &#123; return &#125; _, err = udpConn.Write(buf[0:nr]) if err != nil &#123; return &#125; &#125; &#125;()&#125; 写成这样即可，需要每次读写的时候都重新设置一下，可能对速度造成影响。我们也可以直接设置一个相对安全的值使其尽量不要超时","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道进阶03-处理连接-本地放行+重写目的地址（tcp）","slug":"隧道/隧道进阶03-处理连接-本地放行+重写目的地址（tcp）","date":"2023-10-03T02:08:59.000Z","updated":"2023-10-31T10:59:51.051Z","comments":true,"path":"zh-CN/隧道/隧道进阶03-处理连接-本地放行+重写目的地址（tcp）/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B603-%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5-%E6%9C%AC%E5%9C%B0%E6%94%BE%E8%A1%8C+%E9%87%8D%E5%86%99%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%88tcp%EF%BC%89/","excerpt":"","text":"处理连接-本地放行（tcp）进阶代码下载 基本流程可以理解为 123456789101112// 在demo里面我们异步处理流量// 在这里处理业务流量func process() &#123; for &#123; select &#123; case tcpConn := &lt;-_tcpQueue: go tcpProcessRewrite(tcpConn) case udpPacket := &lt;-_udpQueue: go udpProcessRewrite(udpPacket) &#125; &#125;&#125; 1234567891011121314151617181920// 以tcp流量写一个demo// 本地放行+重写目的地址func tcpProcessRewrite(conn net.Conn) &#123; fmt.Println(fmt.Sprintf(&quot;TCP rewirte dst remote addr:%v local addr:%v&quot;, conn.RemoteAddr().String(), conn.LocalAddr().String())) local, _ := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;10.11.77.12&quot;) remote, _ := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;10.50.1.188:8088&quot;) re, err := net.DialTCP(&quot;tcp&quot;, local, remote) if err != nil &#123; fmt.Println(&quot;net dial error:%v&quot;, err) return &#125; go func() &#123; defer conn.Close() io.Copy(re, conn) &#125;() go func() &#123; defer re.Close() io.Copy(conn, re) &#125;()&#125; 即可实现本地放行 思考题这里使用了net.DialTCP而不是net.Dial，这个方法要多传一个local的ip，这样做的目的是什么？为什么不使用net.Dial？如果有流量通过路由导入到虚拟网卡里面，本地放行的ip和路由到虚拟网卡的ip相同，会出现流量本地死循环的现象，使用net.DialTCP可以有效避免流量死循环，但是要额外指定本机出口网卡ip","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道进阶02-虚拟网卡->用户态处理数据包（选学）","slug":"隧道/隧道进阶02-虚拟网卡->用户态处理数据包","date":"2023-10-02T02:08:59.000Z","updated":"2023-10-31T10:59:47.857Z","comments":true,"path":"zh-CN/隧道/隧道进阶02-虚拟网卡->用户态处理数据包/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B602-%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1-%3E%E7%94%A8%E6%88%B7%E6%80%81%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"虚拟网卡-&gt;用户态处理数据包（选学）进阶代码下载 1234567891011[0 0 0 2 69 0 0 64 0 0 64 0 64 6 187 109 114 2 2 2 10 50 1 21 213 33 33 194 64 111 123 227 0 0 0 0 176 194 255 255 98 116 0 0 2 4 5 180 1 3 3 6 1 1 8 10 164 164 252 161 0 0 0 0][0 0 0 2 69 0 0 52 0 0 64 0 64 6 187 121 114 2 2 2 10 50 1 21 213 33 33 194 64 111 123 228 42 158 136 94 128 16 8 10 200 227 0 0 1 1 8 10 164 164 252 161]TCP remote addr:114.2.2.2:54561 local addr:10.50.1.21:8642[0 0 0 2 69 0 2 115 0 0 64 0 64 6 185 58 114 2 2 2 10 50 1 21 213 33 33 194 64 111 123 228 42 158 136 94 128 24 8 10 155 230 0 0 1 1 8 10 164 164 252 161 232 239 54 26 22 3 1 2 58 1 0 2 54 3 3 213 0 12 255 249 102 134 132 101 124 128 48 20 100 86 18 88 207 47 241 137 186 227 39 60 14 194 87 94 193 139 42 32 200 37 156 47 156 44 208 214 206 4 89 171 36 97 9 167 208 95 200 238 249 231 36 15 101 174 211 104 192 209 0 86 0 32 26 26 19 1 19 2 19 3 192 43 192 47 192 44 192 48 204 169 204 168 192 19 192 20 0 156 0 157 0 47 0 53 1 0 1 205 154 154 0 0 0 16 0 14 0 12 2 104 50 8 104 116 116 112 47 49 46 49 0 27 0 3 2 0 2 68 105 0 5 0 3 2 104 50 0 43 0 7 6 202 202 3 4 3 3 0 5 0 5 1 0 0 0 0 254 13 1 26 0 0 1 0 1 129 0 32 170 238 163 38 173 14 155 27 89 147 241 9 126 118 6 128 223 123 232 113 153 203 158 208 106 37 176 86 33 167 155 86 0 240 118 64 149 34 5 159 87 207 0 9 219 225 22 183 179 221 31 168 252 38 58 77 147 155 233 254 62 110 39 111 202 12 58 99 171 174 96 43 181 128 226 214 247 158 227 211 185 149 14 135 115 29 165 91 208 208 106 250 60 142 202 218 6 86 18 98 198 31 180 155 229 23 229 229 102 111 33 116 85 19 251 174 68 170 253 5 86 6 58 2 98 116 252 177 33 210 90 237 103 68 75 46 1 10 128 125 36 123 253 242 21 112 250 92 242 68 104 129 23 107 159 148 25 61 148 109 165 0 73 116 221 23 82 180 75 172 237 185 155 35 1 184 96 230 12 121 247 1 151 244 122 171 219 108 106 192 24 165 230 243 242 203 77 189 65 122 5 64 151 52 24 138 96 99 103 243 234 174 59 122 163 83 60 118 182 61 157 132 88 234 160 209 33 218 151 17 150 151 196 35 151 114 236 30 34 101 88 225 148 23 173 213 251 120 124 200 35 233 157 200 134 179 123 168 24 170 48 234 8 209 86 53 233 37 124 66 205 169 56 248 255 1 0 1 0 0 11 0 2 1 0 0 45 0 2 1 1 0 35 0 0 0 18 0 0 0 10 0 10 0 8 26 26 0 29 0 23 0 24 0 23 0 0 0 51 0 43 0 41 26 26 0 1 0 0 29 0 32 22 53 48 118 65 49 40 66 186 23 119 101 227 113 7 136 143 154 165 41 180 43 45 226 116 206 187 9 178 181 183 73 0 13 0 18 0 16 4 3 8 4 4 1 5 3 8 5 5 1 8 6 6 1 74][0 0 0 2 69 0 0 52 0 0 64 0 64 6 187 121 114 2 2 2 10 50 1 21 213 33 33 194 64 111 126 35 42 158 136 95 128 16 8 10 198 161 0 0 1 1 8 10 164 164 252 162][0 0 0 2 69 0 0 52 0 0 64 0 64 6 187 121 114 2 2 2 10 50 1 21 213 33 33 194 64 111 126 35 42 158 136 95 128 17 8 10 198 160 0 0 1 1 8 10 164 164 252 162][0 0 0 2 69 0 0 64 0 0 64 0 64 6 187 109 114 2 2 2 10 50 1 21 213 34 33 194 183 63 153 236 0 0 0 0 176 194 255 255 245 98 0 0 2 4 5 180 1 3 3 6 1 1 8 10 117 195 3 186 0 0 0 0][0 0 0 2 69 0 0 52 0 0 64 0 64 6 187 121 114 2 2 2 10 50 1 21 213 34 33 194 183 63 153 237 253 141 223 237 128 16 8 10 49 82 0 0 1 1 8 10 117 195 3 186][0 0 0 2 69 0 2 115 0 0 64 0 64 6 185 58 114 2 2 2 10 50 1 21 213 34 33 194 183 63 153 237 253 141 223 237 128 24 8 10 124 97 0 0 1 1 8 10 117 195 3 186 232 239 54 27 22 3 1 2 58 1 0 2 54 3 3 219 109 171 30 37 38 4 112 212 185 197 155 163 81 76 78 145 199 137 23 208 56 147 89 222 89 217 112 28 75 58 105 32 70 83 17 62 141 9 73 95 229 81 87 234 32 188 237 17 232 210 240 168 203 189 115 211 21 192 69 238 251 73 215 148 0 32 90 90 19 1 19 2 19 3 192 43 192 47 192 44 192 48 204 169 204 168 192 19 192 20 0 156 0 157 0 47 0 53 1 0 1 205 186 186 0 0 0 16 0 14 0 12 2 104 50 8 104 116 116 112 47 49 46 49 0 10 0 10 0 8 10 10 0 29 0 23 0 24 0 45 0 2 1 1 68 105 0 5 0 3 2 104 50 254 13 1 26 0 0 1 0 1 51 0 32 54 249 207 198 26 79 147 70 105 48 182 193 92 208 17 209 220 75 230 64 162 165 113 106 28 17 164 83 182 64 117 72 0 240 2 187 134 250 170 155 196 234 221 48 133 111 84 63 207 172 119 137 43 123 235 160 78 137 180 30 139 165 58 39 122 5 246 148 108 48 134 141 175 207 62 155 209 239 159 213 175 105 99 165 102 226 74 174 186 69 149 167 188 13 46 48 57 109 114 155 99 231 17 139 182 21 160 172 54 222 132 54 9 19 165 22 203 244 26 33 35 197 123 204 54 216 218 22 122 239 173 148 26 167 69 222 14 250 136 248 226 166 43 124 129 65 65 38 185 149 196 16 121 1 78 64 173 21 87 250 197 35 212 138 220 44 67 101 194 13 56 95 111 141 236 230 139 215 99 52 89 97 48 10 188 163 151 33 159 139 78 166 129 190 42 190 150 10 189 176 147 172 173 71 99 214 122 116 35 76 185 26 25 30 21 239 184 100 124 223 233 171 205 94 28 85 198 52 107 235 136 239 13 144 102 52 197 160 226 1 39 75 125 156 2 127 232 167 245 110 93 202 85 157 105 144 73 113 15 103 103 141 50 37 55 87 71 190 43 11 136 223 43 235 0 43 0 7 6 42 42 3 4 3 3 0 13 0 18 0 16 4 3 8 4 4 1 5 3 8 5 5 1 8 6 6 1 0 35 0 0 255 1 0 1 0 0 5 0 5 1 0 0 0 0 0 51 0 43 0 41 10 10 0 1 0 0 29 0 32 137 49 252 31 150 45 111 81 239 225 56 226 210 130 37 110 187 8 16 164 134 217 20 207 148 3 189 255 82 60 48 77 0 27 0 3 2 0 2 0 11 0 2 1 0 0 23 0 0 0 18 0 0 106]TCP remote addr:114.2.2.2:54562 local addr:10.50.1.21:8642 只看第一个数据包 123[0 0 0 2 69 0 0 64 0 0 64 0 64 6 187 109 114 2 2 2 10 50 1 21 213 33 33 194 64 111 123 227 0 0 0 0 176 194 255 255 98 116 0 0 2 4 5 180 1 3 3 6 1 1 8 10 164 164 252 161 0 0 0 0] 后4位是虚拟网卡自己处理了，不是真实的数据 这个时候我们拿到的net.conn对象打印出来的数据TCP remote addr:114.2.2.2:54561 local addr:10.50.1.21:8642 可以看到remote是utun80的虚拟地址，而local是真实的业务地址，和我们理解的反了过来 但是没关系，这个对象就是本地和浏览器建立的socket，读写数据均和浏览器交互 思考题我们从用户态堆栈拿到的net.conn和我们普通建立的net.conn，有没有什么区别？没区别，read和wirte都是给对端的socket发送数据 服务端同时监听多个端口，处理方法也一样，在客户端上和两个不通的端口建立socket，能不能把连接做成连接池？可以，go里面拿到的都是net.conn对象，都放入同一个连接池即可","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道进阶01-点对面隧道","slug":"隧道/隧道进阶01-点对面隧道目标","date":"2023-09-17T02:08:59.000Z","updated":"2023-10-31T11:00:22.968Z","comments":true,"path":"zh-CN/隧道/隧道进阶01-点对面隧道目标/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B601-%E7%82%B9%E5%AF%B9%E9%9D%A2%E9%9A%A7%E9%81%93%E7%9B%AE%E6%A0%87/","excerpt":"","text":"点对面隧道进阶代码下载 （学习本章之前强烈建议先学习隧道基础02-点对点隧道和隧道基础03-自定义协议） 点对面隧道基本流程图 那我们都需要做什么能够达到效果？ 启动虚拟网卡 启动包gvisor.dev&#x2F;gvisor中用户态处理底层数据包，将数据包转化成我们好操作的net.conn对象 拿到对象后根据对象中的 localAddr 和remoteAddr判断是否经过隧道（可能只是想要代理10.50.1.21:22端口，其他端口本地放行，但是路由是不区分端口的，所以需要在代码里面处理本地放行的逻辑） 根据自己自定义协议封装进隧道里面发送到服务端 服务端根据隧道协议判断数据类型并处理","categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道基础04-ip和掩码","slug":"隧道/隧道基础04-ip和掩码","date":"2023-09-16T02:08:59.000Z","updated":"2023-10-23T09:55:39.173Z","comments":true,"path":"zh-CN/隧道/隧道基础04-ip和掩码/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%8004-ip%E5%92%8C%E6%8E%A9%E7%A0%81/","excerpt":"","text":"ip常见ip为，123.249.80.168&#x2F;32，10.50.1.220&#x2F;8，192.168.1.1&#x2F;16 那后面的32，8，16代表的是什么 基础01123.249.80.168&#x2F;32 32表示匹配整个ip 10.50.1.220&#x2F;8 8表示匹配10.* 192.168.1.1&#x2F;16 16表示匹配192.168.* 那如果是7呢，如果是15呢，如果是31呢？ 基础02ip最大值是多少 255.255.255.255 为什么是255？ 看二进制，8个1可以是10进制的255，ip是由于32个0或1组成的 正式内容ip和掩码是如何对应的 ip看成32个0或1组成 10.50.1.220&#x2F;7是如何匹配的呢？ 7其实真实含义为匹配前7个0或者1，后面的25个可以是任意值（0或1都可以） 看一下7的二进制是00001010那我们第一位可以是多少呢？ 由此我们计算出10.50.1.220&#x2F;7可以匹配的ip是 10.*和11.* 来计算一下10.50.1.220&#x2F;6可以匹配什么ip？ （答案） 8.*和9.*和10.*和11.*","categories":[{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道基础05-开发工具使用","slug":"隧道/隧道基础05-开发工具使用（goland）","date":"2023-09-16T02:08:59.000Z","updated":"2023-10-31T07:22:38.292Z","comments":true,"path":"zh-CN/隧道/隧道基础05-开发工具使用（goland）/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%8005-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%88goland%EF%BC%89/","excerpt":"","text":"goland使用基础设置GOROOT第一步需要在这里设置自己的GOROOT 设置错误无法启动自己的项目 开发环境配置-tags设置 这里设置操作系统，cpu等方案，但是不是编译环境，只是开发环境 高级设置sudo启动方案 在本地启动的时候有时候因为权限不够无法启动，需要sudo权限启动，需要把这里勾上即可 远程启动配置 先在idea的这里配置ssh，远程机器一定要有go环境 选择可以看到 后会跳出来下面 直接确认即可 这样勾要选上否则就需要设置环境变量修改编译条件，如果有c的依赖无法在自己本地编译然后点击启动即可在远程机器上启动程序 远程debug配置点击下载: dlv 放入任意地方即可 配置3这里的dlv.path为刚刚的linux的dlv，重启goland后即可直接在idea里面远程debug","categories":[{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"},{"name":"goland使用","slug":"goland使用","permalink":"https://cbbboy.github.io/tags/goland%E4%BD%BF%E7%94%A8/"},{"name":"远程debug","slug":"远程debug","permalink":"https://cbbboy.github.io/tags/%E8%BF%9C%E7%A8%8Bdebug/"},{"name":"sudo方案启动","slug":"sudo方案启动","permalink":"https://cbbboy.github.io/tags/sudo%E6%96%B9%E6%A1%88%E5%90%AF%E5%8A%A8/"}]},{"title":"隧道基础03-自定义协议","slug":"隧道/隧道基础03-自定义协议","date":"2023-09-10T02:08:59.000Z","updated":"2023-10-20T05:34:42.067Z","comments":true,"path":"zh-CN/隧道/隧道基础03-自定义协议/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%8003-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"自定义协议我们有http的协议，有tls协议 那我们能不能自己做一个自定义协议呢？当然可以 我们就先做一个简单的 使用前4个字节当作长度，后面传递其真实内容 x x x x hello! 解析的时候每次先读取4个字节长度后续判断内容长度 123456789101112131415161718192021222324252627282930313233343536// protocol/protocol.gopackage protocolimport ( &quot;fmt&quot; &quot;io&quot;)// Encode 将消息编码func Encode(message []byte) ([]byte, error) &#123; protocolPre := make([]byte, 4) protocolPre[0] = byte(len(message)) protocolPre[1] = byte(len(message) &gt;&gt; 8) protocolPre[2] = byte(len(message) &gt;&gt; 16) protocolPre[3] = byte(len(message) &gt;&gt; 24) fmt.Println(fmt.Sprintf(&quot;encode protocolPre:%v&quot;, protocolPre)) return append(protocolPre, message...), nil&#125;// Decode 解码消息func Decode(reader io.Reader) ([]byte, error) &#123; protocolPre := make([]byte, 4) _, err := io.ReadFull(reader, protocolPre) if err != nil &#123; return nil, err &#125; fmt.Println(fmt.Sprintf(&quot;decode protocolPre:%v&quot;, protocolPre)) b := int(protocolPre[3])&lt;&lt;24 + int(protocolPre[2])&lt;&lt;16 + int(protocolPre[1])&lt;&lt;8 + int(protocolPre[0]) data := make([]byte, b) _, err = io.ReadFull(reader, data) if err != nil &#123; return nil, err &#125; return data, nil&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// clientpackage mainimport ( &quot;fmt&quot; &quot;my-code/tunnel/protocol&quot; &quot;net&quot;)func main() &#123; conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;) if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; for true &#123; var input string fmt.Scanf(&quot;%s&quot;, &amp;input) encode, err := protocol.Encode([]byte(input)) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; _, err = conn.Write(encode) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; &#125; &#125;() for &#123; decode, err := protocol.Decode(conn) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; fmt.Println(string(decode)) &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// serverpackage mainimport ( &quot;fmt&quot; &quot;my-code/tunnel/protocol&quot; &quot;net&quot;)func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;) if err != nil &#123; fmt.Println(err) return &#125; for &#123; conn, err := listen.Accept() if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; for true &#123; var input string fmt.Scanf(&quot;%s&quot;, &amp;input) encode, err := protocol.Encode([]byte(input)) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; _, err = conn.Write(encode) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; &#125; &#125;() go func() &#123; for &#123; decode, err := protocol.Decode(conn) if err != nil &#123; fmt.Println(err) conn.Close() return &#125; fmt.Println(string(decode)) &#125; &#125;() &#125;&#125; 我们抓包后看一下网络上的传输内容是什么样子的 10a 00 00 00 68 65 6c 6c 6f 21 21 21 21 21 这就是图中数据层的内容 前4位是我们的协议内容0a 00 00 00 为什么是0a呢而我们日志里面是10呢，这是因为wireshark是16进制10 &#x3D; 0a 68 65 6c 6c 6f 21 21 21 21 21 即是hello!!!!! 68是16进制，换算成10进制位104，参考https://tool.oschina.net/commons?type=4查询得倒104是h 思考题请把文中明文改为tls加密","categories":[{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道基础02-点对点隧道","slug":"隧道/隧道基础02-点对点隧道","date":"2023-09-03T02:08:59.000Z","updated":"2023-10-30T10:26:40.437Z","comments":true,"path":"zh-CN/隧道/隧道基础02-点对点隧道/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%8002-%E7%82%B9%E5%AF%B9%E7%82%B9%E9%9A%A7%E9%81%93/","excerpt":"","text":"点对点隧道隧道是什么？打通网络的即可叫隧道 如何实现点对点普通隧道？我们可以这样 那我们如何go代码实现？12345678910111213141516171819202122232425262728293031323334353637383940414243// clientpackage mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot;)func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;) if err != nil &#123; fmt.Println(err) return &#125; defer listen.Close() for &#123; conn, err := listen.Accept() if err != nil &#123; fmt.Println(err) return &#125; go processClient(conn) &#125;&#125;func processClient(conn net.Conn) &#123; dial, err := net.Dial(&quot;tcp&quot;, &quot;10.50.1.211:9000&quot;) if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; defer dial.Close() io.Copy(dial, conn) &#125;() go func() &#123; defer conn.Close() io.Copy(conn, dial) &#125;()&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// server 部署在10.50.1.220上package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot;)func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:9000&quot;) if err != nil &#123; fmt.Println(err) return &#125; defer listen.Close() for &#123; conn, err := listen.Accept() if err != nil &#123; fmt.Println(err) return &#125; go processServer(conn) &#125;&#125;func processServer(conn net.Conn) &#123; dial, err := net.Dial(&quot;tcp&quot;, &quot;10.50.1.188:8088&quot;) if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; defer dial.Close() io.Copy(dial, conn) &#125;() go func() &#123; defer conn.Close() io.Copy(conn, dial) &#125;()&#125; 在浏览器上输入http://127.0.0.1:8888/后 通过抓包我们可以看见我们希望访问10.50.1.188:8088的流量直接发给了10.50.1.211，而且是明文直接发送 普通隧道可以看见其中的访问内容，我们可以使用tls进行加密？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// clientpackage mainimport ( &quot;crypto/tls&quot; &quot;fmt&quot; &quot;io&quot; &quot;net&quot;)func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;) if err != nil &#123; fmt.Println(err) return &#125; defer listen.Close() for &#123; conn, err := listen.Accept() if err != nil &#123; fmt.Println(err) return &#125; go processClientTLS(conn) &#125;&#125;func processClientTLS(conn net.Conn) &#123; cfg := &amp;tls.Config&#123; InsecureSkipVerify: true, &#125; dial, err := tls.Dial(&quot;tcp&quot;, &quot;10.50.1.211:9999&quot;, cfg) if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; defer dial.Close() io.Copy(dial, conn) &#125;() go func() &#123; defer conn.Close() io.Copy(conn, dial) &#125;()&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// server 部署在220上package mainimport ( &quot;crypto/tls&quot; &quot;fmt&quot; &quot;io&quot; &quot;net&quot;)func main() &#123; cer := &quot;-----BEGIN CERTIFICATE-----\\nMIICyjCCAiugAwIBAgIFAPb/7TwwCgYIKoZIzj0EAwQwUzEOMAwGA1UEBhMFQ2hp\\nbmExDzANBgNVBAgTBkZ1SmlhbjEPMA0GA1UEBxMGWGlhbWVuMRAwDgYDVQQKEwdH\\nb3Byb3h5MQ0wCwYDVQQDEwRNYXJzMB4XDTIyMDkwNzEwMTEzNVoXDTI0MDkwNzEw\\nMTEzNVowWjEOMAwGA1UEBhMFQ2hpbmExDzANBgNVBAgTBkZ1SmlhbjEPMA0GA1UE\\nBxMGWGlhbWVuMRAwDgYDVQQKEwdHb3Byb3h5MRQwEgYDVQQDEwthaXRydXN0LmNv\\nbTCBmzAQBgcqhkjOPQIBBgUrgQQAIwOBhgAEAE03TmHvLk4/EmYQGonQh/iz2Okn\\nsK5OLTqyUOe4jDyKW1My8zqt/7AkkHzdoA8A3DOH+gySKAcjBxOIT5ZqTDMVAG6m\\nmtjlRwLOCxccDLquoFzvX9lQK+IPki+PFjH3WRgYs2Jiv6ofrG162ft1Rcb0TNw9\\n48T5jgAOedYL1be5cVRIo4GhMIGeMA4GA1UdDwEB/wQEAwIEsDAdBgNVHSUEFjAU\\nBggrBgEFBQcDAgYIKwYBBQUHAwEwDAYDVR0TAQH/BAIwADAfBgNVHSMEGDAWgBQw\\nUaeLynxNMmzhJq9074d8Uotc1TA+BgNVHREENzA1gg0qLmFpdHJ1c3QuY29tggth\\naXRydXN0LmNvbYEXcWluZ3FpYW5sdWRhb0BnbWFpbC5jb20wCgYIKoZIzj0EAwQD\\ngYwAMIGIAkIBX+BsZKzV7pCJ+xrIxEJtY4oj6iKxg4boqZwHv/WSKKTiEB+SRaK8\\nmbczk4TI2D+//FNwnDL6NMcoQeDVkGQYdPsCQgEzITLy8y6CugwqOgtK+F+wRIXs\\ntPPBmcfyxzmarDDlGBgmUmwT06ksBOWmbaNvWODXAxvpxOx/lSza7rFpamf8lQ==\\n-----END CERTIFICATE-----\\n&quot; key := &quot;-----BEGIN EC PRIVATE KEY-----\\nMIHcAgEBBEIBSSumcBKzmWrzFCC+Sjz2bxapycjUn21EAtjI9W1byE6oyqmsgRiH\\nuLeM2T09+7CIa1ykePHcbiWmgRw50RJyGiOgBwYFK4EEACOhgYkDgYYABABNN05h\\n7y5OPxJmEBqJ0If4s9jpJ7CuTi06slDnuIw8iltTMvM6rf+wJJB83aAPANwzh/oM\\nkigHIwcTiE+WakwzFQBupprY5UcCzgsXHAy6rqBc71/ZUCviD5IvjxYx91kYGLNi\\nYr+qH6xtetn7dUXG9EzcPePE+Y4ADnnWC9W3uXFUSA==\\n-----END EC PRIVATE KEY-----\\n&quot; keyPair, err := tls.X509KeyPair([]byte(cer), []byte(key)) if err != nil &#123; fmt.Println(fmt.Sprintf(&quot;load basic config error:%v&quot;, err)) return &#125; cfg := &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;keyPair&#125;, CipherSuites: []uint16&#123; tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, &#125;, MinVersion: tls.VersionTLS12, MaxVersion: tls.VersionTLS13, &#125; listen, err := tls.Listen(&quot;tcp&quot;, &quot;0.0.0.0:9999&quot;, cfg) if err != nil &#123; fmt.Println(err) return &#125; defer listen.Close() for &#123; conn, err := listen.Accept() if err != nil &#123; fmt.Println(err) return &#125; go processServerTLS(conn) &#125;&#125;func processServerTLS(conn net.Conn) &#123; //dial, err := net.Dial(&quot;tcp&quot;, &quot;172.31.255.10:8643&quot;) dial, err := net.Dial(&quot;tcp&quot;, &quot;10.50.1.188:8088&quot;) if err != nil &#123; fmt.Println(err) return &#125; go func() &#123; defer dial.Close() io.Copy(dial, conn) &#125;() go func() &#123; defer conn.Close() io.Copy(conn, dial) &#125;()&#125; 在浏览器上输入http://127.0.0.1:8888/后 即可发现我们的隧道已经是tls加密隧道了 例子中使用了如下代码1io.Copy(conn, dial) 那我们如何写一个自己的方法实现和他同样的效果？ 12345678910111213141516go func() &#123; defer func() &#123; conn.Close() &#125;() buf := make([]byte, 1024*32) for &#123; nr, err := remoteConn.Read(buf) if err != nil &#123; return &#125; _, err = conn.Write(buf[0:nr]) if err != nil &#123; return &#125; &#125;&#125;() 替换一下变量名字即可启动，实现io.copy的方法","categories":[{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]},{"title":"隧道基础01-标准协议","slug":"隧道/隧道基础01-标准协议","date":"2023-09-02T02:08:59.000Z","updated":"2023-10-20T06:01:35.500Z","comments":true,"path":"zh-CN/隧道/隧道基础01-标准协议/","link":"","permalink":"https://cbbboy.github.io/zh-CN/%E9%9A%A7%E9%81%93/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%8001-%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"标准协议tcp、udp、ssh、http、vmess、vless、tls、dns、grpc他们的区别与联系 这个是wireshark的抓包界面，那分别代表什么意思呢 1 代表的是所有数据包，默认按时间排序当1选中数据包后 2、3会显示详细信息 2代表的是wireshar将数据包解析后人为能读懂的内容，像圈中的Protocol：TCP不是数据包中的内容，是wireshark根据数据包3中圈出位置的字符翻译出他代表的含义 3代表的是原始数据包，即网络上传输的内容，一般我们自己是无法读懂的，一般都看2中的内容 这个是一个tls协议的流量，他同时也叫tcp，为什么会这样呢？ 看这个wireshark抓包的protocol，这个06代表的即是tcp协议 那为什么又会叫tls协议呢？tcp上承载的数据内容是tls的流量，所以叫做tls 这个时候我们就能很清晰的认识到 协议分成tcp，udp，icmp tcp会根据承载的数据分成http、tls、ssh等 udp会有dns、quic、arp等 那除了tcp是6、udp是多少呢？除了tcp和udp还会有其他什么协议？协议列表官方文档 https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml 有很多，不过目前只有tcp、udp、icmp允许在公网上传输，内网允许部分协议","categories":[{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"}]}],"categories":[{"name":"隧道进阶","slug":"隧道进阶","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E8%BF%9B%E9%98%B6/"},{"name":"隧道基础","slug":"隧道基础","permalink":"https://cbbboy.github.io/categories/%E9%9A%A7%E9%81%93%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"隧道","slug":"隧道","permalink":"https://cbbboy.github.io/tags/%E9%9A%A7%E9%81%93/"},{"name":"加密隧道","slug":"加密隧道","permalink":"https://cbbboy.github.io/tags/%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93/"},{"name":"goland使用","slug":"goland使用","permalink":"https://cbbboy.github.io/tags/goland%E4%BD%BF%E7%94%A8/"},{"name":"远程debug","slug":"远程debug","permalink":"https://cbbboy.github.io/tags/%E8%BF%9C%E7%A8%8Bdebug/"},{"name":"sudo方案启动","slug":"sudo方案启动","permalink":"https://cbbboy.github.io/tags/sudo%E6%96%B9%E6%A1%88%E5%90%AF%E5%8A%A8/"}]}